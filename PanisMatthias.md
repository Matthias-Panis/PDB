![Front Page ](../PDB/Images/FrontPage.jpg)

# Inhoud

[1	Projectdefinitie	](#1-projectdefinitie)

[2	Voorwoord	](#2-voorwoord)

[3	Omschrijving Bachelorproef	](#3-omschrijving-bachelorproef)

[4	IST-Situatie	](#4-ist-situatie)

[5	SOLL-Situatie	](#5-soll-situatie)

[6	ACTEA team ](#6-actea-team)

 [6.1	Van Grieken Geert ](#6-1-van-grieken-geert)

 [6.2	Sasha Pampus ](#6-2-sasha-pampus)

 [6.3	Florian Maximillian Eichel ](#6-3-florian-maximillian-eichel)

 [6.4	Panis Matthias ](#6-4-panis-matthias)

[7	Software vereisten	](#7-software-vereisten)

 [7.1	TIA PORTAL	](#7-1-tia-poral)

 [7.2	FactoryIO	](#7-2-factoryio)

[8 Cursus](#8-cursus)

[9	Bibliografie	](#9-bibliografie)

[10	Figuurlijst	](#10-figuurlijst)

[11 Bijlagen](#11-bijlagen)




# 1 Projectdefinitie

Mijn project zal gaan over het schrijven van een cursus in automatisatie.
Het project is een internationaal Erasmusproject, genaamd ACTEA project waarbij Mr. Van Grieken ontwikkelaar
is van cursusmateriaal en didactisch materiaal en levert hij technische
ondersteuning op vlak van PLC-uitrusting. Hij heeft mij als hulp ingeschakeld om een cursus rond Advanced PLC te
vervolledigen. Het project heeft als doel om de bevolking in Oost-Afrikaanse landen op te leiden in STEM technieken op het niveau van een professionele bachelor.

Om de levensstandaard in Oost-Afrikaanse landen te verbeteren bied dit project
een zekere meerwaarde. Bovendien is er een grote vraag naar technici van
investeerders, ngo’s en de opkomende middenklasse. Om aan deze vraag te kunnen
voldoen, is er behoefte aan bekwame mensen, opgeleid in relevante technische
beroepen, maar die zijn moeilijk te vinden vanwege de sterke theoretische
benadering aan de universiteiten in plaats van praktijkgericht
competentiegericht onderwijs.

Het ACTEA-project heeft tot doel te voldoen aan de specifieke behoeften op het
gebied van engineering, betere afstemming van vaardigheden te bieden,
cursusmateriaal te leveren in 2 specialisaties, computerondersteunde
fabricagetechnologie en elektrotechniek & automatisering, en technologische
laboratoria op te richten met virtuele en externe toegankelijkheid, leermiddelen
opzetten, academisch personeel aanvullende opleiding over technologie en in het
ontwikkelen van technologisch cursusmateriaal volgens EU-normen.

Zoals eerder vermeld is Mr. Van Grieken ontwikkelaar in cursusmateriaal en
didactisch materiaal. Hierbij zal ik mee helpen en hier zal mijn bachelor proef
dan ook over gaan.

# 2 Voorwoord

Ik studeer op het departement Wetenschap & Techniek van AP-Hogeschool Welke zicht bevindt in de campus Spoor Noord - Ellermanstraat 33 in Antwerpen. Ik volg hier de opleiding Elektromechanica met de afstudeerrichting Automatisatie. Hier doe ik ook mijn bachelorproef voor het ACTEA-project welke een samenwerking is van de volgende universiteiten en hogescholen:
- Hogeschool West-Vlaanderen
- Fachhochschule Dortmund
- Technological Educational Institute of Crete
- Mekelle University Ethiopia
- Jimma University (Jimma Institute of Technology)
- Mbarara University of Science and Technology
- Muni University
- Mzumbe University
- Ardhi University
- Research and Education Network for Uganda
- Tanzania Education and Research Network

Hierbij worden er STEM-cursussen ingericht voor gebruik in Oost-Afrikaanse landen waaronder, Ethiopië, Oeganda en Tanzania. Deze cursussen bestaan uit 2 grote modules, module 1: "Computer Aided Manufacturing Technology”, module 2 "Electrical Engineering & Automation" en ten slotte module 3 : "Labor Market Skills".
Ik zit in de groep die verantwoordelijk is over module 2 "Computer Aided Manufacturing Technology" en bevat volgende cursussen.
- Electrical Installations
- Electrical Motors & Drives
- Basic PLC Programming
- Advanced PLC & Motion
- Sensor Technology
- Process Simulation & Control
- Renewable Energy
- Embedded Measurement and Control


Waaruit "Advanced PLC & Motion" mijn verantwoordelijkheid zijn.


# 3 Omschrijving Bachelorproef

Ik zal bestaande cursusmateriaal omzetten naar het Engels. Dit cursus materiaal bevatten ook schema's en oefening die ik zal hermaken / hernoemen naar de correcte engelse benamingen. De oefening zal ik zelf allemaal moeten uittesten en naar de correcte engelse benamingen omzetten. Ik maak gebruik van Atom om deze cursus in Markdown [^1] te schrijven en heb ook in Atom mijn PDB geschreven. Atom is een tekst editor vooral gemaakt voor bv. markdown bestanden mee te schrijven. Verder gebruik ik ook GitHub om de cursusses en mijn aanpassingen te uploaden en downloaden. Mensen met de juiste link hiernaar kunnen dan deze cursussen en bestanden online bekijken.

De PDB zelf heb ik dan ook in een .md bestandformaat geschreven gebruik makend van [Atom](https://atom.io/). Deze is dan geexport naar een HTML pagina die dan in een PDF versie gepresenteerd wordt. Dit PDB staat ook op een persoonlijke repository op [Github](https://github.com/Matthias-Panis/PDB/blob/master/PDB-PanisMatthias.md)

[^1]: Markdown is een opmaaktaal op basis van platte tekst die ontworpen is voor HTML gebaseerde webpagina's. (Bestandsextensie .md)

# 4 IST-Situatie
- Advanced PLC boek is nog niet vervolledigen
- ADD01[^2] Electrical drawings
- ADD02 TAG Name

# 5 SOLL-Situatie
- Elektonische Advanced PLC boek geschreven
- EX01[^3] Industrial Networks
- EX02 ANSI/ISA S88
- EX03 Sequential controllers
- EX04 Continue controllers
- EX05 HMI displays
- ADD03 Manuals
- ADD04 GRAFCET
- ADD05 controllers
- ADD06 S88

[^2]: ADD = Addendum, een onderwerp wordt hierin volledig uitgelegd.
[^3]: EX = Exercise, een oefening die de student zal kunnen maken.

# 6 ACTEA Team

Via Microsoft Teams worden er meetings georganiseerd. Hier gaat ook alle communicatie door. Als er een hoofdstuk klaar is voor controle communiceer ik via deze weg met het team.

## 6-1 Van Grieken Geert
Lector en onderzoek van de AP Hogeschool Antwepen verbonden aan de opleiding professionele bachelor Elektromechanica van het departement Wetenschap en Techniek.
Gespecialiseerd in industriële automatisatie voor de maakindustrie en interne logistieke transporten.

Is binnen het ACTEA-project verantwoordelijk voor de cursussen “M2C3 Basic PLC programming” en “M2C4 Advanced PLC programming”. In zijn functie als cursusverantwoordelijke verzorgt hij de aansturing van de internationale “writing teams” inclusief de uitwerking, opvolging en ondersteuning van het technisch didactisch materiaal voor deze cursussen.

## 6-2 Sasha Pampus

## 6-3 Florian Maximillian Eichel

## 6-4 Panis Matthias
Student (ik) die verantwoordelijk is voor de uitwerking van de cursus "Advanced PLC & Motion"

# 7 Software vereisten

In de cursus is er gebruik gemaakt van Siemens TIA Portal V16 en Real Games Factory IO 2.4.X. TIA Portal is een computerprogramma dat gebruikt wordt om de oefeningen die aan bod zullen komen te programmeren en uit te voeren op een PLC. FactoryIO is een simulatie programma dat waarin je verschillende scénes kunt maken van echte machine's. Deze scènes en machines die gebouwd zijn in FactoryIO kunnen gesimuleerd worden om met een PLC te communiceren. Hiermee kan een student zijn programmatie controleren zonder effectief de machine voor hun te hoeven hebben. Dit is geweldig makkelijk voor studenten omdat ze het live kunnen controleren met de simulatie van een "echte" machine.

Om deze programma's uit te kunnen voeren zal je PC tenminste met deze specificaties moeten voldoen.

## 7-1 Tia Portal

| **Hardware/Software**| **Requirement** |
| :---: | :---: |
| Processor | Intel® Core ™ i5-6440EQ (up to 3.4 GHz) |
| RAM | 16 GB (min. 8 GB, 32 GB for large projects) |
| Hard disk   |  SSD with 50 GB free storage space  |
| Network   |  1 Gbit (for multi-user) Laptops need WiFi |
| Monitor   |   15.6 "full HD display (1920 x 1080 or more) |
| Operating system	 |  ![Tia portal minimum requirements ](../PDB/Images/TiaPortalMinReq.jpg) |

## 7-2 FactoryIO

| **Hardware/Software**| **Requirement** |
| :---: | :---: |
| Processor | CPU with SSE2 instruction set support |
| GPU/ Video Card   | NVIDIA since 2006 (GeForce 8), AMD since 2006 (Radeon HD 2000), Intel since 2012 (HD 4000 / IvyBridge)  |
| RAM | 8 GB |
| Hard disk   |  SSD with 10 GB free storage space  |
| Network   |  1 Gbit (for multi-user) Laptops need WiFi |
| Monitor   |   15.6 "full HD display (1920 x 1080 or more) |
| Operating system	 |  Windows 7 SP1+ or higher |


# 8 Cursus

Ik behandel het gedeelte M2C4 wat de advanced cursus is van automatisatie cursus.
Deze cursus bevat volgende hoofdstukken:
- Addendum 3 **HMI**
- Addendum 4 **GRAFCET**
- Addendum 5 **Controllers**
- Addendum 6 **Software model following S88**
- Exercise 1 **Industrial networks**
- Exercise 2 **ANSI/ISA S88**
- Exercise 3 **Sequential controllers**
- Exercise 4 **Continue controllers**
- Exercise 5 **HMI displays**

Link naar [Github](https://github.com/ACTEA-Erasmus/m2c4-aplc) repository van ACTEA

De hele cursus is in het engels geschreven, gebruik makend van Atom. Deze is te vinden in de [Bijlagen](#11-bijlagen)

## 8-1 Addendum 3 HMI
Dit addendum heb ik met hulp van Siemens pdf's zelf samen gesteld (HMI Tutorial). Dit is ook in het engels geschreven maar heb het terug naar nederlands vertaald hier.

Engelse volledige versie [Bijlagen](#hmi-programming-in-siemens-tia-portal-v16)

In dit hoofdstuk wordt het HMI en hoe men deze gebruikt in TIA portal besproken.
Men legt uit hoe je de HMI toevoegd via TIA portal. Dit kan zowel via het portal view of project view. Vervolgens wordt men door de device selectie geleid. Als de juiste HMI geselecteerd is zal de HMI wizard tevoorschijn komen. Hierin wordt elke opties uitgelegd en de functies ervan.

Als dit allemaal geconfigureerd is kunnen we verder naar de "Device configuration". Hierbij zullen we eerste de HMI moeten configureren. <p><p>
![Steps GRAFCET](../PDB/Images/Step12.jpg)

In de device configuratie wordt uitgelegd waar men de juiste IP instellingen ingegeven wordt. Als dit ingesteld is zal de CPU en het HMI Paneel worden gecompiled. Als er geen errors zijn kunnen we verder naar het ontwerpen van de schermen.
In dit hoofdstuk legt men uit hoe je een scherm aanpast met verschillende elementen. Deze elementen kunnen via de Toolbox van TIA Portal worden geselecteerd. Vervolgens bespreekt men the "Basic objects", "Elements", "Events" en "Animations".

Onder de **basic objects** zitten de volgende voorwerpen;

- Text box
- Rectangle
- Circle
- Line
- Ellipse
- Graphic view

Deze delen ongeveer dezelfde eigenschappen (hun lay-out en de make-up ervan).
Dit kan aangepast worden in de properties tab.
Het speciale aan een **Graphic view** is dat men custom afbeeldingen in het HMI schermen kan steken. Dit is uitgelegd hoe men het doet in de cursus.

De **"elements"** zijn figuren die kunnen gelinked worden met PLC data. Deze bestaan uit;

- I/O-Field
- Button
- Symbolic I/O-Field
- Graphical I/O-Field
- Date/Time Field
- Bar
- Switch

Een I/O-Field kan dus ingesteld worden om bv. een integer waarde vanuit de plc te lezen en/of wegschrijven. Deze functionaliteit wordt in de properties veranderd onder "General".

De **events** kunnen toegepast worden op elk object of figuur op een HMI scherm.
Deze events kunnen verschillende functies doen bv. ![Steps GRAFCET](../PDB/Images/Step24.jpg)
In de cursus leg ik het gebruik van "SetBitWhileKeyPressed" dit zal de functionaliteit van een drukknop nabootsen.

De **animations** bestaat onder 2 verschillende toepassingen die men kan kiezen.
Deze zijnde ;

- Display
- Movements

Het display zal de optie geven om de "visibility" aan te passen. Hierdoor kan je voorwerpen tevoorschijn of verbergen aan de hand van een waarde.

De movements bestaan onder 4 verschillende sub categoriëen;

- Direct movement
- Diagonal movement
- Horizontal movement
- Vertical movement

Deze bepalen hoe het object zal bewegen. Dit is ook weer linkbaar met een variabel.


## 8-2 Addendum 4 GRAFCET

In dit hoofdstuk wordt een GRAFCET uitgelegd. Hiervan was al een Nederlandse cursus door Mr. Van Grieken geschreven. Deze heb ik dan volledig omgezet van Nederlands naar Engels. Afbeeldingen die eerst in het Nederlands stonden zijn dus ook in Ms Excel aangepast naar de correcte Engelse benamingen. Hier had Mr. Van Grieken ook al een Ms Excel file van met al de correcte Nederlandse benamingen.

Engelse volledige versie [Bijlagen](#grafcet)

Een voorbeeld van de afbeeldingen in Ms Excel :

![Excel GRAFCET](../PDB/Images/ExcelGrafcet.jpg)

In Ms Excel kan je de rasterlijnen laten verdwijnen door "Pagina-indeling" > "Uitlijnen" > "Rasterlijnen weergeven" af te vinken. Hierdoor verdwijnen de rasterlijnen. Hierna gebruik makend van de snipping tool in Ms Windows kan de gewenste afbeelding worden geselecteerd.

Verder is deze addendum ook opgedeeld in 5 subchapters:
- [Subchapter01](#grafcet) zal gaan over de algemene uitleg
- [Subchapter02](#designing-of-a-grafcet-in-iec-60848) zal gaan over het ontwerpen van een GRAFCET
- [Subchapter03](#grafcet-programming-in-lad/fbd-using-bool) zal gaan over de GRAFCET taal geprogrammeerd in TIA Portal (Bool) [Bijlagen]
- [Subchapter04](#grafcet-programming-in-lad-fbd-using-int) zal gaan over de GRAFCET taal geprogrammeerd in TIA Portal (INT)
- [Subchapter05](#grafcet-programming-in-st) zal gaan over de GRAFCET taal geprogrammeerd in TIA Portal (ST)

Voor subchapter 3 tot 5 komt er ook TIA Portal programmatie voor. Deze zijn ook vertaald naar het Engels. Gebruik makend van de Nederlandse voorbeelden in de bestaande cursussen heb ik dan in TIA Portal deze bouwstenen nagemaakt maar dan met de Engelse benamingen.

## 8-3 Addendum 5 Controllers

In dit hoofdstuk worden de verschillende controllers uitgelegd. Hiervan was al een Nederlandse cursus door Mr. Van Grieken geschreven. Deze heb ik dan volledig omgezet van Nederlands naar Engels. Afbeeldingen die eerst in het Nederlands stonden zijn dus ook in Ms Excel aangepast naar de correcte Engelse benamingen. Deze heb ik zelf nagetekent in Ms Excel.

Door middel van de kolombreedte op 2 en de rijhoogte op 15 krijg je een mooi vierkant. Hiermee kunnen we nu zelf de sturing na tekenen. Om het makkelijker te makken om de lijnen en vormen uit te lijnen activeren we de optie "Uitlijnen op raster". De optie kan terug gevonden worden onder "Pagin-indeling" > "Uitlijnen".
Met behulp van deze functies zijn de sturing getekent in Ms Excel: <P>

![Excel GRAFCET](../PDB/Images/Excelcontrollers.jpg)

Verder is deze addendum ook opgedeeld in 5 subchapters:
- [Subchapter01](#characteristics-and-defenitions) zal gaan over de eigenschappen en begrippen
- [Subchapter02](#on-off-circuit) zal gaan over een aan-uit controller
- [Subchapter03](#pid-controller) zal gaan over een PID controller
- [Subchapter04](#singular-control-circuit) zal gaan over regelkring structuren

## 8-4 Addendum 6 S88

In dit hoofdstuk bespreken we het S88 software model. Hierbij is er een standaard AP library gebruikt. Ook deze zal omgezet worden van Nederlands naar Engels, later worden de library gebruikt om oefeningen mee te maken. Deze heb ik dan volledig omgezet van Nederlands naar Engels.
Afbeeldingen die eerst in het Nederlands stonden zijn dus ook in Ms Excel aangepast naar de correcte Engelse benamingen. Hier had Mr. Van Grieken ook al een Ms Excel file van met al de correcte Nederlandse benamingen.

Een voorbeeld van de afbeeldingen in Ms Excel :
<p>

![Excel S88](../PDB/Images/ExcelS88.jpg)

![Excel S88](../PDB/Images/ExcelS882.jpg)

De engelse library ziet er als vogt uit:<P>

![Excel GRAFCET](../PDB/Images/TIALibrary.jpg)

Om in TIA Portal de Nederlandse library aan te passen moet je de functie blok in TIA portal slepen. Dan pas je deze aan door op "edit the type" te klikken nadat je de functie blok hebt geopend. <P>

![TIA Edit Type ](../PDB/Images/tiaedittype.jpg)

Als dan alles correct is aangepast zal deze blok als een nieuwe versie worden "gereleased". Dit ziet er als volgt uit: <P>

![TIA Release Type](../PDB/Images/tiareleasetype.jpg)

Dit is gedaan voor elk controle module en process element. Om dit bruikbaar te maken voor later gebruik zal er een nieuwe library aangemaakt moeten worden in de "Global Library" tab. Deze library is genoemd "S88 TIA Portal V16" <P>

![TIA library export](../PDB/Images/tialibraryexport.jpg)

Volgende stap is er een archive van te maken. Dit gebeurd door te rechtsklikken op "S88 TIA Portal V16", wat een menu opent met de optie "Archive library..."<P>

![TIA archive](../PDB/Images/tiaarchive.jpg)

De archived library wordt opgeslagen bij oefening 2 onder "Documents" <P>

![TIA archive library](../PDB/Images/tiaarchivefinal.jpg)

De archived library zal gebruikt worden in oefening 2.

Verder is deze addendum ook opgedeeld in 5 subchapters:
- [Subchapter01](#software-model-following-ansi-isa-88) zal gaan over de algemene uitleg
- Subchapter02 zal gaan over sensoren
- Subchapter03 zal gaan over het aansturen van motoren door een controle module
- Subchapter04 zal gaan over de controle module voor een ventiel en contactor
- Subchapter05 zal gaan over geeft voorbeelden

## 8-5 Exercise 1

## 8-6 Exercise 2

Oefening 2 is een toepassing op S88. De student leert een S88 ontwerp om te zetten naaar een software design. Ook zullen ze leren om de volgende functies uit te voeren in TIA Portal:
- Het retrieven van een archived programma
- Het retrieve van een archived library
- Het importen van een external source file

De oefening is opgebouwd rond de FactoryIO scene Pick And Place. <P>

![Factory IO Pick and place scene](../PDB/Images/pickandplace.jpg)

Hiervoor is een S88 software model gemaakt in het Nederlands, dit is vertaald naar het Engels in Ms Excel.<P>

![Excel S88](../PDB/Images/S88PnP.jpg)

De bedoeling zal zijn dat de student deze S88 zal programmeren. Alvorens ze dit kunnen doen zullen ze een archived programma moeten retrieven. Deze heb ik zelf gemaakt en bevat het S88 gedeelte met de drukknoppen, motor beveiligingen en contactors: <p>

![Factory IO Pick and place scene](../PDB/Images/FC_EM_CC1.jpg)
Deze heb ik geprogrammeerd in TIA Portal:<P>

![Factory IO Pick and place scene](../PDB/Images/TIAFC_EM_CC1.jpg)

Dit hoeft de student dus niet meer programmeren, wel zijn er de instructies om het archived project te downloaden / kopiëeren naar het de juiste bestandslocatie. Hierna zijn er nog instructies om het programma te openen.

De volgende stap zal zijn om de library die gemaakt is in [8-3 Addendum 06](#8-3-addendum-6-s88) te retrieven. Deze bevat al de nodige controle modules om de oefening correct te laten werken.

Er is een tag lijst aangemaakt in de opgaven van de oefening die ze zelf moeten overnemen.
```javascript
//Inputs
iCC1_McbConveyorIn_Q1 - BOOL - %I 0.0 - Motor circuit breaker for conveyor belt entry
iCC1_McbConveyorOut_Q2 - BOOL -	%I0.1	- Motor circuit breaker for conveyor belt exit
iPnP_Sen_B1 -	BOOL - %I10.0 - Sensor item at entry
iPnP_Sen_B2 - BOOL - %I10.1 - Sensor item at exit
Moving X - BOOL - %I10.2 - Robot is moving in the X axis
Moving Z - BOOL - %I10.3 - is moving in the Z axis
Vacuum - BOOL -	%I10.4 - The vacuum of the robot is active
iCC1_BtnStart_S1 - BOOL	- %I10.5 - Start button
iCC1_BtnReset_S3 - BOOL	- %I10.6 - Reset button
iCC1_BtnStop_S2	- BOOL - %I10.7	- Stop button
iCC1_BtnEms_S4	- BOOL - %I11.0	- Emergency stop button


//Outputs
iCC1_McbConveryorIn_K1 - BOOL - %Q10.0 - Contactor conveyor belt entry
iCC1_McbConveyorOut_K2 - BOOL - %Q10.1 - Contactor conveyor belt exit
Move X - BOOL - %Q10.2 - Moves the robot in the X axis
Move Z -  BOOL - %Q10.3 - Moves the robot in the Z axis
Grab - BOOL - %Q10.4 - Grabs an item
oCB1_LmpError_H1 - BOOL - %Q10.7 - Error lamp


//Flags
mM001 - BOOL - %M50.0 - System started
mA001 - BOOL - %M50.1 - Motor circuit breaker conveyot belt entry alarm
mA002 - BOOL - %M50.2 - Motor circuit breaker coneyor belt exit alarm

mZ - BOOL - %M60.1 - Flag move Z-axis of the robot
mGrab - BOOL - %M60.2 - Flag grab item
mReset - BOOL - %M60.3 - Flag reset
mSysFALSE - BOOL - %M60.4 - Flag FALSE
mStopIn	- BOOL - %M60.6 - Flag stop conveyor belt entry
mStopOut - BOOL - %M60.7 - Flag stop conveyor belt exit
mSen_TO_B1 - BOOL - %M61.0 - Flag sensor B1
mSen_TO_B2 - BOOL - %M61.1 - Flag sensor B2
mSysIlnit	- BOOL - %M60.5 - Flag initilization

```
Om de student wat te helpen is er nog 1 controle module over namelijk:<P>
![Factory IO Pick and place scene](../PDB/Images/EX2example.jpg)

Verder zullen ze de S88 zelf moeten programmeren aan de hand van de gegeven S88 software model.
Om hun software te testen moeten ze de GRAFCET importeren via een external source file. Deze is meegeleverd in de oefening en noemt "FB-P_PickAndPlace.scl" als ze dit correct importeren via "External source files", hebben ze een werkende GRAFCET en kunnen ze de oefening testen. Het bestand "FB-P_PickAndPlace.scl" heb ik gegenereerd uit een zelf geschreven scl block. Die de volgende GRAFCET volgt:<P>

![Generate source from block](../PDB/Images/generatesource.jpg)
![Grafcet Pick and place](../PDB/Images/Grafcet.jpg)

De GRAFCET is vertaald in Ms Excel. Origineel was dit een Nederlandse versie gemaakt door Mr. Van Grieken.

De uiteindelijke verwachte werking: [Youtube](https://youtu.be/1GHui4iEm5c)

# 9 Bibliografie
[HMI Tutorial](https://www.automation.siemens.com/sce-static/learning-training-documents/tia-portal/visualization-s7-1200/sce-041-101-wincc-basic-ktp700-s7-1200-r1709-en.docx)

# 10 Figuurlijst

# 11 Bijlagen

## 11-1 Cursus

# HMI programming in Siemens TIA Portal V16
## Introduction

Due to production processes are becoming more and more complex and requirements for machine and plant functionality are increasing, operators need a powerful tool for controlling and monitoring production plants. An HMI system (human-machine interface) represents the interface between man (operator) and process (machine/plant). It is the controller that actually controls the process. Hence, there is an interface between the operator and WinCC (at the HMI device) and an interface between WinCC and the controller.

## Device description

The SIMATIC HMI Basic Panels product line features key and touch panels (operator input via keyboard and touch screen)
SIMATIC HMI Basic Panels cover all requirements described in the previous section.

## Hardware configuration

For a HMI to be correctly used in TIA Portal V16, one will need to make the right hardware configuration. For this to be correct you will need a correct CPU configuration mentioned in M2C3-ADD03.

To add a HMI to a current project you will have to add a new device. This can be done through the 2 views within TIA portal.

| Project View | Portal View |
| :---: | :---: |
|  "New Device"  |  "Devices & network > Add new device" |
| ![TIA Portal Adding HMI](../PDB/Images/Step1.jpg)  |  ![TIA Portal Adding HMI](../Ad03/Images/Step1-1.jpg) |

The menu that pops up has 3 main options to select between Controllers / HMI / PC systems. For our example we'll be needing the HMI tab:

![TIA Portal Adding HMI](../PDB/Images/Step2.jpg)

After which you select the desired HMI. HMI > SIMATIC Basic Panel (we'll be using the simulator of TIA Portal, for this example i took the KTP1500 Basic):

![TIA Portal Adding HMI](../PDB/Images/Step3.jpg)

# HMI wizard

When you selected the correct/desired HMI you get the following screen presented:

Here you need to link the HMI to the correct PLC, this is done by selecting the right PLC under Select PLC -> PLC_1

![TIA Portal Adding HMI](../PDB/Images/Step4.jpg)

If the correct PLC is selected it should automatically link the HMI to the PLC through ProfiNET.
Now proceed to the next screen by pressing "Next".

![TIA Portal Adding HMI](../PDB/Images/Step5.jpg)

You can change the default background color of your panel under "Screen layout".
Select the "Header", "Date/time" and "Logo" check boxes. Confirm your selection by clicking on "Next ".

![TIA Portal Adding HMI](../PDB/Images/Step6.jpg)

In the "Alarms" section, you can specify which of the alarms are to be displayed in a window. Select all three alarm types. Confirm your selection by clicking on
"Next".

![TIA Portal Adding HMI](../PDB/Images/Step7.jpg)

In the "Screen navigation" section, the screen structure is displayed with the screen name of the last created project, starting with the root screen on the far left. A new name can be assigned simply by clicking on a screen name.
If you click on + you can insert new screens in the hierarchy ® and delete selected screens by clicking on "Delete screen".
Confirm your selection by clicking on "Next".

![TIA Portal Adding HMI](../PDB/Images/Step8.jpg)

In the System screens section, you can select previously preset views for system functions and have them automatically added. Select all system screens by clicking "Select all". Confirm your selection by clicking on "Next".

![TIA Portal Adding HMI](../PDB/Images/Step9.jpg)

In the System buttons section, you will find four user-selectable buttons for Exit(Runtime), Log on, Language and Root screen. You can place these buttons on the provided button areas "Left", "Bottom" or "Right" as desired. An "Open alarm window" button is already created.

Select only the "Button area", "Bottom".Insert the button for the "Root screen" on the left and the button for "Exit" Runtime on the right. Confirm your selection by clicking on "Finish".

![TIA Portal Adding HMI](../PDB/Images/Step10.jpg)

# Device configuration of HMI Panel

The TIA Portal now automatically changes to the Project view and displays the root screen of the visualization.

![TIA Portal Adding HMI](../PDB/Images/Step11.jpg)

To configure the panel, select "Panel KTP700 Basic" in the project tree and open its "Device configuration" with a double-click.

![TIA Portal Adding HMI](../PDB/Images/Step12.jpg)


## Setting the IP adress

Select the Ethernet interface of the panel in the Device view with a double-click.
Under "General" in "Properties", open menu item "PROFINET interface [X1]" and select in the "Ethernet addresses" entry.
Set the IP address "192.168.0.10" under IP protocol.

![TIA Portal Adding HMI](../PDB/Images/Step13.jpg)

**Remarks**
–	The subnet mask was already set in the settings of the CPU 1215C and is automatically applied by the panel.

## Compiling the CPU and panel and saving the project

To compile the CPU, click on the "CPU_1215C" folder, and select the "Compile" button for compiling in the menu. To compile the panel, click on the "Panel KTP1500 Basic" folder, and select the "Compile" button for compiling in the menu. You can save your project by clicking on the "Save Project"  button in the menu.
( CPU_1215C > "Compile" > Panel KTP700 Basic > "Compile" > Save project  ).

![TIA Portal Adding HMI](../PDB/Images/Step14.jpg)

In the "Info" area under "Compile", it is then shown whether the compilation was successful or whether warnings or errors have occurred.

![TIA Portal Adding HMI](../PDB/Images/Step15.jpg)

# Changin screens and objects
## Screens
After successful compilation, you want to design the first screen for the visualization. To do this, open the > "Root" screen with a double-click:

![TIA Portal Adding HMI](../PDB/Images/Step16.jpg)

You will see a text box in the center of the screen, we will remove this by right clicking the text box and selecting "Delete". This also can be done by pressing you keyboard button "Delete".

![TIA Portal Adding HMI](../PDB/Images/Step17.jpg)

## Toolbox
These contain the most commonly used objects, elements and controls used in a HMI display.<p><p>
![TIA Portal Adding HMI](../PDB/Images/Step18.jpg)

### Basic objects

The basic objects contain a text box, rectangle, circle, line, ellipse and a graphic view.
These are added by simply dragging them onto on the screen or selecting one in the toolbox section and clicking on the desired screen. To customise them further you'll have to click on the properties of the object. For example a rectangle, in the properties you can change the appearance, layout and miscelaneous.

![TIA Portal Adding HMI](../PDB/Images/Step19.jpg)

These properties are the same for all basic objects except for the text box and graphic view.
Graphic view has the ability to show custom images. This is done by selecting the grpahic view and placing it on a screen. Then in options you'll have to go to General > bottom button to add custom files. There is already a pre existing list of images you can choose from. But to add a custom image:
![TIA Portal Adding HMI](../PDB/Images/Step20.jpg)

### Elements
The elements are objects that can be linked to actual PLC data / are ment to be used as a way of interacting with PLC data. These stock ones contain an I/O-Field, button, symbolic I/O-Field, graphical I/O Field, date/time field, bar and a switch. Once dragged into the screen you can change the appearance however you want and link them with the correct PLC data type. For example an I/O-Field.

![TIA Portal Adding HMI](../PDB/Images/Step21.jpg)

In the properties of this I/O field you can assign a Tag from the HMI or PLC to it. This will read out the value that tag has. An I/O field is mostly used for reading or giving in a desired value. In "format" you can customise how the value gets displayed. For example:

![TIA Portal Adding HMI](../PDB/Images/Step22.jpg)

You can also change the type of I/O field by changing it to input or output only. Input only will only show input values. Output only will only allow a measured value to be displayed and NOT changed.

## Events

Each object or element can have events. These can change values, screens on the HMI, calculations scripts etc.. For an example we'll use a button to make it behave like a Start button.

![TIA Portal Adding HMI](../PDB/Images/Step23.jpg)

To assign a function to the button you click on "Properties" > "Events" > "Click" > "< Add function >" you will get the following selection.

![TIA Portal Adding HMI](../PDB/Images/Step24.jpg)

Select "Edit bits", in here there are several options of changing a bit. For a start button the most common function is "SetBitWhileKeyPressed", this will set the asigned bit to 1 while you press the button. If you release the button the bit value will be set to 0 again.


## Animations

### Display

Within the properties screen you can find the tab "Animations". After which you get the option to add either a **Display** or **Movements**. In this chapter i'll explain the **Display**.

![TIA Portal Adding HMI](../PDB/Images/Step25.jpg)

Within a display you can have a "Appearance" or "Visibility" animation. The appearance will give you the ability to change the colours of a object depending on a tag value. Visibility will give you the option to hide the object depending on a tag value.

### Movements

Within **movements** there are 4 different movements, direct movement, diagonal movement, horizontal movement and vertical movement. Direct movement will allow you to move a object from point A to B in a direct way. Diagonal movement will move from point A to B diagonally. Horizontal movement will move from point A to B horizontaly. Vertical movement will move from point A to B vertically.

Horizontal and vertical movement can be assigned to a tag value so that depending on that value the object will move towards one point. For example:

![TIA Portal Adding HMI](../PDB/Images/Step26.jpg)

The range will determine how much of your tag value will be used (0-50 of the tag value will move your object between the two points in that range 0 being point A and 50 being point B).

# GRAFCET
## General
[8.2 Addendum 4 GRAFCET](#8-2-addendum-4-grafcet)

The implementation of an automated system requires, in particular, a description relating cause and effect. To do this, the logical aspect of the desired behaviour of the system will be described.

The **sequential part** of the system is the logical aspect of this physical system. The behavior indicates the way which the output variables depend on the input variables. The object of the GRAFCET chart is to specify the behavior of the sequential part of the system.

The **GRAFCET design language** is characterized by different graphical elements and by text that gives information about the variables. By connecting these various elements and text, the behavior of the automatic machine/installation is described.

This behavior is known as steps and a GRAFCET contains multiple steps. The evolution of one step to another is translated by one or several transitions.

![Sequential process](../PDB/Images/Sequential_process.jpg)

A GRAFCET will be executed as follows:
-   A GRAFCET will run from top to bottom
-   A GRAFCET starts with an initial step
-   A transition is displayed as a mathematic boolean expression
-   The result of a transition is TRUE or FALSE
-   While the GRAFCET is executed there is at least one active step
-   Only steps connected to the active step can be executed
-   Other steps can be activated on the condition that they are connected with the active step if the result of the connected transition is TRUE

There are 5 programming languages included in the standard IEC 61131 including SFC[^4] which is inspired on the GRAFCET design language. However, there are some differences:
  -   SFC is a programming language
  -   GRAFCET is a design language
  -   The SFC program language uses other program languages, such as FBD and LAD, and different abbreviations to program transitions and actions
  -   The execution of an OR-convergence, if all conditions are TRUE, is  different

[^4]: SFC = Sequential Function Chart, Siemens uses the name GRAPH

<sub>        Conclusions
-	It is possible to program a GRAFCET in each programming language described in the standard IEC 61131
-	The SFC program language looks like GRAFCET design language but is not 100% the same </sub>

# Designing of a GRAFCET in IEC 60848
[8.2 Addendum 4 GRAFCET](#8-2-addendum-4-grafcet)
## GRAFCET diagram

| **Symbol**| **Description** |
|:---:      |:---             |
|![Grafcet Diagram](../PDB/Images/GRAFCET_Diagram.jpg) | A GRAFCET diagram is a collection of steps, actions, transitions, connections, etc. which form a complete diagram. The collection of all elements is surrounded by a rectangle. |
|![Input Variables](../PDB/Images/Input_Variables.jpg) | **Input variables** are on the left with an incoming arrow <p><p>__Example__: "Initial step activation" and "installation started" inputs <p> ![Input Variables Example](../PDB/Images/Input_VariablesEx.jpg)                                                                                                    |
|![Output Variables](../PDB/Images/Output_Variables.jpg)| **Output variables** are located on the right with an outgoing arrow. <p><p>__Example__: "Forward" and "Backward" output signals.<p> ![Output Variables Example](../PDB/Images/Output_VariablesEx.jpg)                                                                                                                        |
|"*" | A **comment** clarifies the working of certain parts and is written between double quotation marks, whereby the asterisk symbol gets replaced by the description.<p><p>  __Example__: Stop a drain  pump if the level is too low. <p> ![Comments](../PDB/Images/Comments.jpg)                               |

## Step
A **step** displays a defined condition of the sequential process. A step is either **Active** or **Not Active**.

On a certain moment during the sequential proces:
-   Is a step active or not active
-   The set of active steps determines the state of the process
-   The GRAFCET determines which step or steps can become active

| **Symbol** | **Descpription** |
| :---:      | :----            |
|![Step](../PDB/Images/Step.jpg)       | A **step** is shown as a square with an unique label. For practical reasons the most commonly used label are numbers which replaces the asterisk symbol.<p><p> __Example__: Step 2 <p>       ![Step Example](../PDB/Images/Step_2.jpg) |
| ![Initial Step](../PDB/Images/Initial_Step.jpg) | The **initial step** characterizes the initial situation and is displayed as a double square. In case of the initial step being active, all other steps in the GRAFCET won’t be active.<p><p> __Example__: Step 0 <p><p> ![Initial Step Example](../PDB/Images/Initial_StepEx.jpg) |
| ![Enclosed Step](../PDB/Images/Enclosed_Step.jpg) | An **enclosed step** means that this step contains other steps. If the conditions after the enclosed step are TRUE, we will proceed to the next step and all internal steps will be inactive.<p><p> It is allowed that an enclosed step contains multiple GRAFCET diagrams, but the enclosed internal steps can only be assigned to one enclosed step. |
| ![Enclosed Initial Step](../PDB/Images/Enclosed_Initial_Step.jpg)       | An **enclosed initial step** means that this step has multiple internal steps that participate in the initial condition.<p><p> The enclosed initial step contains minimum one internal initial step and can contain multiple GRAFCET diagrams. |
| ![Macro Step](../PDB/Images/Macro_Step.jpg) | A **macro step** means that this step has multiple internal steps. We can describe it as an independent piece of software. A macro is not designed as standalone software, it’s meant to support a different piece of software. <p><p> The internal steps always start with a source step and always end with an end step. Only in the case of the end step being active can the macro exit. Unlike an enclosed step, a macro contains a maximum of one GRAFCET diagram and the asterisk symbol gets replaced by one unique label that can deviate from step labels, in numbered order. |
| ![Active Step](../PDB/Images/Active_Step.jpg) |  In case that an **active step** needs to be displayed, this will be done by placing a point under the label.|

## Connections
| **Symbol** | **Description** |
| :---:      | :---            |
| ![Connectionelements](../PDB/Images/Connectionelements.jpg) | Connections are lines in the network that connect steps. |
| ![Horizontal Connectionelements](../PDB/Images/ConnectionelementsHorizontal.jpg) | Both horizontal and vertical lines are allowed. <p><p>Diagonal lines are to be avoided. They are allowed, but only to clarify. |
| ![Flow Connection](../PDB/Images/FlowConnection.jpg) | The flow of a connection is always from top to bottom.<p><p> The use of arrows is allowed in case of clarification. |
| ![Disconnected](../PDB/Images/Disconnect.jpg) | If a directed link has to be broken (for example for complex charts or when a chart covers several pages) the number of the destination steps and the number of the page on which it appears, shall be indicated. <p><p>__Example__: Reference to step 12 on page 2<p><p> ![Disconnected Example](../PDB/Images/DisconnectEx.jpg)|

## Transition
| **Symbol** | **Description** |
| :---:      | :---            |
| ![Condition](../PDB/Images/Condition.jpg) | A transition between two steps is indicated by a horizontal line right through the connection line. <p><p> The transition-condition is active if the previous step is active. <p><p> Between 2 steps one condition is allowed. |
| ![Condition Horizontal](../PDB/Images/Condition_Horizontal.jpg) | It’s allowed to use vertical transitions for graphical reasons. |
| ![Transition Condition](../PDB/Images/Transition_Condition.jpg) | Each transition contains a condition. This is a mathematical boolean expression composed by variables, they replace the asterisk symbol. The result of a transition-condition is TRUE or FALSE. <p><p>The transition-condition is always at the right of the transition. <p><p> __Example__: Start button AND stop button <p><p>![Transition Condition Example](../PDB/Images/Transition_ConditionEx.jpg) |
| ![Transition Number](../PDB/Images/Transition_Number.jpg) | The transition may have an unique designation ( ) at the left of the transition.<p><p> __Example__: Label 6 <p><p>![Transtion Number Example](../PDB/Images/NumberingEx.jpg) |
| ![Always TRUE](../PDB/Images/Always_TRUE.jpg) | A transition condition that is always TRUE is displayed with the underscored expression 1. |
| ![Step Status](../PDB/Images/Step_Status.jpg) | The status of a step (active or not active) can be added in a transition-condition with the capital letter "X".<p><p> The asterisk symbol will be replaced by a label of the step.<p><p> __Example__: Step variable of step 7 |       |  |
| ![Increasing Flank](../PDB/Images/Increased_Flank.jpg) | An upward arrow in the transition-condition means that it is only TRUE the moment the variable changes from FALSE to TRUE. <p><p>__Example__: The transition-condition is TRUE on a rising edge of the "Door is Open" sensor OR if the "Door Limit switch" is activated. ![Increasing Flank Example](../PDB/Images/Increased_FlankEx.jpg)   |   |   |
| ![Decreasing Flank](../PDB/Images/Decreasing_Flank.jpg)| A downward arrow in the transition-condition means that it is only TRUE the moment the variable changes from TRUE to FALSE.<p><p> __Example__: The transition condition is TRUE on a decreasing flank of the pallet fotocel.<p><p>![Decreasing Flank Example](../PDB/Images/Decreasing_FlankEx.jpg) |
| ![Comparison Instruction](../PDB/Images/Comparison_Instructionjpg.jpg)| A **comparison** is noted between [ ].<p><p> The asterisk symbol gets replaced with a comparison.<p><p>  The result of a comparison instruction is TRUE or FALSE. <p><p>__Example__: The transition-condition is TRUE in case the actual pressure is higher than 5,0 bar. <p><p> ![Comparison Instruction Example](../PDB/Images/Comparison_InstructionEx.jpg) |
|![Time Condition](../PDB/Images/Time_Condition.jpg) | A variable that is time dependent is displayed with the **/** symbols (TON / variable / TOF). <p><p> Hereby, the transition-condition is TRUE after an on-delay and stays TRUE with an off-delay. It is allowed to simplify the notation by removing the off-delay in case this isn’t used. <p><p>__Example__: The transition condition is TRUE 2 s after the iSen is TRUE  and stays 5s TRUE after iSen becomes FALSE.<p> ![Time Condition Example 1](../PDB/Images/Time_VariableEx.jpg) <p><p>__Example__: 3 s after step 4 is activated the transition-condition becomes TRUE and step 5 will be activated.<p><p>![Comparison Instruction](../PDB/Images/Time_ConditionEx.jpg)
| ![Source Transition Condition](../PDB/Images/Source_Transition_Condition.jpg)  |  A **source transition-condition** is a transition-condition without previous steps. Each time the transition condition is TRUE, the next step will be activated. It is recommended to provide a transition condition with a rising or dropping flank to avoid the activation of the next step. <p><p>__Example__:The initialization step 0 will be activated on a rising flank from the initialization input signal.<p><p>     ![Source Transition Condition Example](../PDB/Images/Source_Transition_ConditionEx.jpg) |
|  ![End Transition Condition](../PDB/Images/End_Transition_Condition.jpg) |  An **end transition-condition** is a transition-condition where no steps follows. Each time the transition condition is TRUE, the upwards steps will be disabled.  <p><p>__Example__:  Sequence with initialization of a sourcestep where all steps get activated ![End Transition Condition Example](../PDB/Images/End_Transition_ConditionEx.jpg)|
  Explanation symbolic image
  -	iInit = digital input – GRAFCET initialise
  -	iStarted = digital input – Result of a start-stop circuit
  -	iSen1 = digital input – Sensor 1
  -	iSen2 = digital input – Sensor 2

## Action
| **Symbol** | **Description** |
| :---:      |:---             |
| ![Action](../PDB/Images/Action.jpg) | An **action** is assigned to a step and gets illustrated by a rectangle which is connected to that step with a horizontal line.<p><p> It is allowed to use multiple actions in the same step, if each of them have their own rectangle.<p><p> **Allowed multiple actions:** ![Action Example](../PDB/Images/ActionEx.jpg) |
| ![Action Label](../PDB/Images/Action_Label.jpg) | Each action has an action label which clarifies the executed task.<p><p> The label is written in the rectangle where the asterisk symbol is replaced by a variable.<p><p> A **continue action** will have the status of the variable TRUE the moment the corresponding step is active. All other moments the action is FALSE.<p><p>__Example__: The pump action is TRUE on step 4 and FALSE on step 5<p><p> ![Action Label Example](../PDB/Images/Action_LabelEx.jpg) |
| ![Memory Action](../PDB/Images/Memory_Action.jpg) | A **memory action** has a specific value assigned to a variable which gets stored. The asterisk symbol gets replaced by a variable and the \# symbol gets replaced by a (mathematical) value, formula, .... . <p><p>__Example__: The lamp gets activated in step 7, is still activated in step 8 and turns off in step 9. The internal variable "sX" is increased by 1 in step 8.<p><p> ![Memory Action](../PDB/Images/Memory_ActionEx.jpg) | ![Conditional Action](../PDB/Images/Conditional_Action.jpg) | A **conditional action** gets the status TRUE in case of the corresponding step being active and the assigned actioncondition is TRUE. <p><p>__Example:__ The disapproval lamp lights up in case the amount of disapproved parts are bigger then 3 in case step 5 is active. ![Conditional Action Example](../PDB/Images/Conditional_ActionEx.jpg) |
| ![Conditional Action Example Time Dependent](../PDB/Images/Conditional_Action_Timedependant.jpg) | A time dependent **conditional action** is displayed with the / symbols. The action is TRUE after an on-delay and stays TRUE with an off-delay. It is allowed to simplify the condition by removing the off-delay in case this isn't used. <p><p>__Example__: 2s after "iSen" becomes TRUE valve A+ will be activated. 5s after "iSen" become FALSE valve A+ will be deactivated if step 9 is activated.<p><p>![Conditional Action Example Time Dependent Example](../PDB/Images/Conditional_Action_TimedependantEx1.jpg) <p><p>__Example__: 3s after step 4 is activated the OK lamp lights up.<p><p>![Conditional Action Example Time Dependent Example](../PDB/Images/Conditional_Action_TimedependantEx2.jpg) |
| ![Memory Action Activation](../PDB/Images/Memory_ActionActivation.jpg) | It is possible to run a memory action with the activation of a step. This is indicated with an upwards arrow. <p><p>__Example__: With the activation of step 8 the formula will be ran. <p><p>![Memory Action Activation](../PDB/Images/Memory_ActionActivationEx.jpg) |  | ![Memory Action Deactivation](../Ad04/Images/Memory_ActionDeactivation.jpg) | It is possible to run a memory action with the deactivation of a step. This will be shown as a downwards arrow. |   |
Explanation of the used symbols:
-	oPump = digital output – Activation of a pump
-	oLmp = digital output – Activation of a lamp
-	oLmpOK = digital output – Activation of an OK lamp
-	oVlvA_1 = digital output – Activation of Valve A+
-	sX = static variable X
-	sNumNOK = static variable – Amount of NOK parts

## Structures
| **Symbol** | **Description**  |
| :---:      | :-----           |
| ![Sequence](../PDB/Images/Sequence.jpg) |A **sequence** is a series of steps where each step contains max. one transition-condition.<p><p> The sequence is active if at least one step of the sequence is active. The sequence is inactive when all steps are inactive. |
| ![ Loop Sequence](../PDB/Images/Loopsequence.jpg) | A simple **loop sequence** is a sequence of steps whereby each step contains max. one transition-condition and where the last step is connected to the first step. |
| ![ Sequence With Source Step](../PDB/Images/SequenceWithSourceStep.jpg) | A **sequence with source step** has a step without previous transition- condition. <p><p>__Example__: Sequence with a initializing sourcestep.<p><p> ![ Sequence With Source Step Example](../PDB/Images/SequenceWithSourceStepEx.jpg) |
| ![ Sequence With End Step](../PDB/Images/SequenceWithEndStep.jpg) | A **sequence with end step** has a step where there are no transition- conditions after it. An end step (and a source step) are necessary with macros. |
| ![ Forward Sequence Jump](../PDB/Images/ForwardSequenceJump.jpg) | It is possible to jump to a step with a **forward sequence skip**.<p><p> Notice that between 2 steps only one transition is allowed. |
| ![ Backwards Sequence jump](../PDB/Images/BackwardsSequenceJump.jpg)       | It is possible to loop back with a **backwards sequence skip**. This makes it possible to repeat a sequence.<p><p> Notice that between 2 steps only one transition is possible. |
| ![ OR-Convergence](../PDB/Images/OR-Convergence.jpg) | Using a **OR-convergence** makes it possible to choose between different sequences where between 2 steps only one transition is allowed. The designer needs to make sure that both sequences can't be activated at the same time. <p><p>__Example__: In the GRAFCET version A it is possible to activate both step 4 and 5. This can happen when "iSen1" and "iSen2" have the status TRUE and in the moment step 3 is active. In the GRAFCET version B it isn't possible due to the extended transition-condition.<p><p>![ OR-Convergence Example](../PDB/Images/OR-ConvergenceEx.jpg) |
| ![ AND-Convergence ](../PDB/Images/AND-Convergence.jpg) | A **AND-convergence** allows to activate parallel sequences at the same time. They will be started after a starting transition.<p><p> An startind AND-convergence is showed by means of a double line after the starting transition.<p><p> Once the parallel sequence is activated both sequences will run seperatly from each other.<p><p> An AND-convergence gets back ends if all the parallel end steps are active and the ending transition-condition is TRUE. An ending AND-convergence is showed by a double line before the ending transition. |

## Function rules
The **function of a GRAFCET** is in general step by step.
If a step is active and the transition condition(s) are met than the next step will be activated. If the next step gets activated the previous step will be deactivated immediately.

It is possible that the status of the different transtion-conditions the fucntion of a GRAFCET seems not to run step by step. It is the task of the designer to avoid that functions which can cause an unstable function of actions.

| **Function** | **Description** |
| :---         | :---            |
| ![ Non transient action ](../PDB/Images/TransitionFunction.jpg) | A **non transient action**  will run step by step.<p><p> Situation: Step 4 active, iSen1 = iSen2 = Isen3 = FALSE <p><p> Function: iSen1 (1) is TRUE which activates step 5 and deactivates step 4. |
| ![ Transient Function ](../PDB/Images/TransientFunction.jpg) | With a **transient action** the steps won't run step by step.<p><p> Situation Step 4 active, iSen1 = iSen3 = FALSE iSen2 = TRUE <p><p>Function: iSen (1) is TRUE which causes step 5 to be activated and step 4 gets deactivated. Because iSen3 (2) is true, step 6 will inmediatly be activated and step 5 will be deactivated.<p><p> Disadvantage: In case we use an action instead of a memory action, it is possible that the assigned actions of a transient step are not or transient executed (= unstable function).|
|       ![ And Convergence ](../PDB/Images/ANDFunction.jpg)        | An **AND-convergence** parallel sequences will be started in case the previous transition condition is TRUE.<p><p> Situation 1: If step 1 is active and transition conditoin iGestart is TRUE then step 2 and 4 will be activated.   <p><p> Situation 2: Once the parallel sequences are activated they will run separatly.<p><p> Situation 3: Step 9 gets activated in case step 3 and step 6 are active and in case the transition-condition "iSen1.iSen2" is TRUE. |

## Example
The next example shows a GRAFCET for the functionality of a conveyor belt. A box is displaced 5x times from start to end before it stops. After this operation it is necessary to restart the installation.
<p><p>

![ Conveyor belt ](../PDB/Images/ConveyorBeltEx.jpg)


The GRAFCET has the name FB_PE_BeltFwBw:

-   FB = GRAFCET will be programmed in a function block (FB)
-   PE = This part is a procedure element according ANSI/ISA S88 standard
-   BeltFwBw = Conveyor belt forwards & backwards

The conveyor belt is **started and stopped** by means of a start button and a stop button. The functionality of these buttons is not included in the GRAFCET but gets executed by an external start-stop basic circuit. The result of this start-stop basic circuit will be linked with the GRAFCET input variable "iStarted".
<p><p>

![ Start Stop exaple ](../PDB/Images/StartStopEx.jpg)
<p><p>
Each time the stop button is pressed the conveyor belt will immediatly stop. When the start button is pressed again, the conveyor and GRAFCET continues where they ended.
<p><p>

![ Conveyorbelt GRAFCET ](../PDB/ConveyorbeltGRAFCET.jpg)
<p><p>
The **photocell** sensors on the conveyor belt detects the presence of the box when the infrared beam between photocell and reflector is interrupted. The status of the photocells (%I) is linked with the GRAFCET input variables "iSenFw" and "iSenBw".
<p><p>

![ Processing Sensors ](../PDB/Images/ProcessingSensors.jpg)
<p><p>
Controlling the conveyor belt forwards and backwards will be determined by step 1 and step 2 on condition that the installation is started.
<p><p>

![ Controlling the conveyorbelt ](../PDB/Images/UpwardsEx.jpg)
<p><p>
The effective **control of the conveyor belt** happens by the GRAFCET output variables "oBeltFw" and "oBeltBw" which are linked to the contactors (%Q) and the conveyor belt motor (asynchronous motor).<p><p>

![ Processing of contactors ](../PDB/Images/ProcessingContactors.jpg)

Counting of the **number of backward and forward movements** is controlled by the internal INT variable "i". This variable is an internal function block parameter of the type STATIC. This makes it possible to remember the condition of variable "i" also without voltage (=retentive). <p><p>

![ Variable example ](../PDB/Images/IncreasingVariableEx.jpg)
<p><p>
Increasing the variable "i" is executed in step 3, after which step 1 gets activated because there is a loop sequence between step 3 and step 1 but only if the value of the variable "i" is less than the decimal value 5. Noticed that the increasing of the variable "i" is only executed on the moment that step 3 is activated (rising edge). This is to prevent wrongly increasing the value of the variable in case step 3 is active longer the one PLC cycle.

In case the box went 5x backwards and forward this will be displayed with a green OK lamp. This lamp (%Q) is connected with the GRAFCET output variable "oOk". Now the installation needs to be stopped with the stop button before the installation can restart.
<p><p>

 ![ Lamp Processing ](../PDB/Images/ProcessingLamp.jpg) ![ Lamp Processing ](../PDB/Images/ProcessingLamp2.jpg)

<p><p>
It is possible to **initialize** the GRAFCET. This is the activation of the initial step (step 0) by using GRAFCET input variable "iInit". All the other active steps get deactivated. The initialising is only activated on the rising edge of "iInit".
<p><p>

![iInit Grafcet Example ](../PDB/Images/iInitGRAFCET.jpg)

You could choose to initialize the installation in case you press the start and stop button simultaneously for 5 seconds or more.

![Activating iInit Grafcet Example ](../PDB/Images/ActivatingiInitGRAFCET.jpg)

# GRAFCET programming in LAD-FBD using BOOL
[8.2 Addendum 4 GRAFCET](#8-2-addendum-4-grafcet)

Converting a **GRAFCET design to software code** is demonstrated with the GRAFCET described in subchapter 2.

The GRAFCET is programmed in the LAD or FBD programming language in the function block (%FB) with the use of STATIC parameters. STATIC parameters can remember their status without the PLC being powered on if they are configured to retain.

![Interface variables ](../PDB/Images/SiemensVarLAD.jpg)

The programming is split into **3 parts** which are chronologically programmed in different networks:
-   Initialization (network 1)
-   Transition-conditions (network 3 ... x)
-   Actions (network x+1 ... last network)

The **GRAFCET programming in LAD/FBD with BOOL** follows the next rules
-   Each step is repesented by an unique BOOL variable
-   This variable is an ARRAY of BOOL starting with 0 and ending with max. step number
-   In case the corresponding variable is TRUE, the step will be active
-   Input "iInit" is always present which causes the activation of the initial step on a rising edge of this input
-   Input "iStarted" is always present which processes the result of an external start-stop basic circuit

![FBD  ](../PDB/Images/SiemensiInitLAD.jpg)
![FBD  ](../PDB/Images/SiemensFBD.jpg)
![FBD  ](../PDB/Images/SiemensFBD2.jpg)
![FBD  ](../PDB/Images/SiemensFBD3.jpg)
![FBD  ](../PDB/Images/SiemensFBD4.jpg)
![FBD  ](../PDB/Images/SiemensFBD5.jpg)
![FBD  ](../PDB/Images/SiemensFBD6.jpg)

| **Advantages** | **Disadvantages** |
| :---:          | :---:             |
| Simplicity (1 step = 1 variable) | Initial step is not activated during the first download of the program |
|                                | Monitoring of active steps is complicated        |

# GRAFCET programming in LAD-FBD using INT
[8.2 Addendum 4 GRAFCET](#8-2-addendum-4-grafcet)
Converting a **GRAFCET design to software code** is demonstrated with the GRAFCET described in subchapter 2.

The GRAFCET is programmed in the LAD or FBD programming language in the function block (%FB) with the use of STATIC parameters. STATIC parameters can remember their status without the PLC being powered on if they are configured to retain.

![Siemens VAR ](../PDB/Images/SiemensVarINT.jpg)

The programming is split into **3 parts** which are chronologically programmed in different networks:
-   Initialization (network 1)
-   Transition-conditions (network 3 ... x)
-   Actions (network x+1 ... last network)

The **GRAFCET programming in LAD/FBD with INT** follows the next rules
-   Only the actual step needs to be known
-   The actual step is represented by an STATIC INT variable (step)
-   The initial value of this variable is the decimal value 0
-   The actual value of this variable corresponds to the active GRAFCET step
-   The initial step is automatically activated the first time the software is downloaded to the PLC; this is because the INT number initial value is equal to the decimal value 0
-   Input "iInit" is always present which causes the activation of the initial step on a rising edge of this input
  - Input "iStarted" is always present which processes the result of an external start-stop basic circuit

![INT ](../PDB/Images/SiemensINT1.jpg)
![INT ](../PDB/Images/SiemensINT2.jpg)
![INT ](../PDB/Images/SiemensINT3.jpg)
![INT ](../PDB/Images/SiemensINT4.jpg)
![INT ](../PDB/Images/SiemensINT5.jpg)
![INT ](../PDB/Images/SiemensINT6.jpg)

| **Advantages** | **Disadvantages** |
| :---:          | :---:             |
| Initial step is activated during the first download of the program | More complex, advanced programming then with LAD/FBD BOOL method |
| Monitoring of active steps is easier | Programming of AND-convergence is more complex then with LAD/FBD BOOL variant |

# GRAFCET programming in ST
[8.2 Addendum 4 GRAFCET](#8-2-addendum-4-grafcet)
Converting a **GRAFCET design to softwarecode** is demonstrated with the GRAFCET described in subchapter 2.

The GRAFCET is programmed in the LAD or FBD programming language in the function block (%FB) with the use of STATIC parameters. STATIC parameters can remeber their status also without voltage if they are configured as retain.<P>

![Siemens ST ](../PDB/Images/SiemensVARST.jpg)

The programming is split into **3 parts** which are chronologically programmed in different networks:
-   Initialisation (network 1)
-   Transition-conditions (network 3 ... x)
-   Actions (network x+1 ... last network)

The **GRAFCET prgramming in ST** is submitted to the next rules
-   The use of CASE .. OF .. ELSE control structure which handles the processing of transition-conditions
-   Only the actual step needs to be known
-   The actual step is represented by a STATIC ANY_INT variable (step)
-   The initial value of this variable is the decimal value 0
-   The actual value of this variable corresponds to the active GRAFCET step
-   The initial step is automatically activated the first time the software is downloaded to the PLC; this because the INT number initial value is equal to the decimal value 0
-   Input "iInit" is always present which causes the activation of the initial step on a rising edge of this input
-   Input "iStarted" is always present which processes the result of an external start-stop basic circuit

![STL ](../PDB/Images/SiemensST.jpg)
![STL ](../PDB/Images/SiemensST2.jpg)
![STL ](../PDB/Images/SiemensST3.jpg)
![STL ](../PDB/Images/SiemensST4.jpg)

| **Advantages**| **Disadvantages** |
| :---: | :---: |
| Initial step is not activated while the the first download of the program | More complex programming than LAD/FBD variant |
| Smaller programming then LAD/FBD variant | Programming of AND-convergence is more complex than the LAD/FBD BOOL method |
| Monitoring of active steps are easier | Debugging [^5] in ST is harder than in FBD/LAD |

[^5]: Debugging = Searching for (programming) faults

## Characteristics and defenitions
[8.2 Addendum 5 Controllers](#8-3-addendum-5-controllers)
Controllers are used mainly to control continuing processes. Also non continuing can be controlled. This way a GRAFCET can run t he controller as action in a determined step. We use analog sensors to control analog or digital actuators.

Controllers are defined by several characteristics which are explained in the table below.


| **Definition**         | **Abbreviation** | **Description**                                                                                                                                                                                                                                                                                               |
|--------------------|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Process value     | X *PV*        | The value measured by the analog sensor *German name = Istwert*                                                                                                                                                                                                          |
| Setpoint   | W *SP*        | The value that we want to achieve. *German name = Sollwert*                                                                                                                                                                                                                   |
| Loop manipulated value      | Y *LMN*       | The result that the actuator that affects the process adjusts *German name = Regelabweichung*                                                                                                                                                                   |
| Error      | E *ER*        | Difference between measured values and the setpoint *German naming = Stellgrösse*                                                                                                                                                                                                     |
| Hysteresis         | H             | The area wherein an actuator gets turned on and off.                                                                                                                                                                                                                                                      |
| Dead band          | XDo *Db*      | The area in which multiple digital acutators get turned off. With analog actuators the status of the output that isn't in the dead band changes.H *German name = Bandbreite*                                                                                                 |
| Dead time         | T0/Tt Td      | The time delay between the change of the loop manipulated value and the change of the measured value. *German name = Totzeit*                                                                                                                                                     |
| Gain        | Kr *GAIN*     | The proportional action or P-action amplifies the output in proportion to input. The magnitude is determined by the gain factor, which can be positive or negative.                                                                                              |
| Reset time     | TI            | The integrating action ensures a constant sum of the error and keeps outputting more signals depending on how long an error exists between the measured and desired value. The integrator or I action is characterized by the time response of the integrator  |
| Derivative time | TD            | The D action responds to the rate of change of the error. So only when creating a step will the D action give its contribution to the controller. The differentiating action or D action is characterized by the time response of the differentiator           |


The measure difference is the difference between the loop manipulated value and the measured value.

E=W-X

Notice that the control difference can have a positive or a negative value.

## On-off circuit
[8.2 Addendum 5 Controllers](#8-3-addendum-5-controllers)
The **on-off circuit** gets used to switch a control output Y [BOOL] on or off in function of a measured value X [REAL] and a set value W [REAL]. The on-off switch ensures that the actuator does not switch on and off too often by using 2 threshold values, namely:
- The switch-on threshold value (lower limit)
- The switch-off threshold value (upper limit)

![ON_OFF](../PDB/Images/ON-OFFeX.jpg)

The difference between the switch-on and switch-off threshold values becomes the so
called hysteresis. The following mathematical formulas apply:

Switch-on threshold or lower limit = X -  Hysteresis/2.0
Switch-off threshold or upper limit = X +  Hysteresis/2.0

 **FBD**
 ![Siemens Example](../PDB/Images/SiemensEx1.jpg)



 **LD**
 ![Siemends Example](../PDB/Images/SiemensEx2.jpg)

In case the process value is lower then the switch-on threshold, the loop manipulated value will be turn off.
As soon as the process value reaches the switch-off threshold, the loop manipulated value will be turn off.

**FBD**
![Siemends Example](../PDB/Images/SiemensEx3.jpg)

**LD**
![Siemends Example](../PDB/Images/SiemensEx4.jpg)


 **Example on-off switch - Heating in a home**
  Homes are often equipped with a thermostat to measure and control the temperature in a room.
  - The thermostat measures the room temperature = measured value X
  - The ideal temperature is entered on the thermostat = desired value W
  - If it is too cold, the thermostat ensures that the boiler is switched on = closed contact = control output Y on
  - If it is too hot, the thermostat ensures that the boiler is switched off = open contact = control output Y off
  - Depending on the type of thermostat, the hysteresis is a fixed value or adjustable (order of magnitude 0.5 to 1.0 ° C)

## PID controller

[8.2 Addendum 5 Controllers](#8-3-addendum-5-controllers)

### Functioning

A PID controller is used to control processes via an analog actuator
[Y = INT or WORD]. A PID controller consists of several sub-functions. So, one distinguishes:

  - P or Proportional action

  - I or Integrative action

  - D or Differentiating action


### Compact PID controller

The compact Siemens PID controller is limited compared to the continuous PID controller in its possibilities. Most of the parameters can be set via associated pop-up menus and can therefore only be set using a programming device (PC with TIA Portal).

As an advantage it can be quoted that configuring this controller is done by using these pop-up screens which is much easier. This way one can make a choice between the different quantities and different SI units and one can opt to operate via a normalized input (output) or a periphery (entrance exit).

![Siemens Example](../PDB/Images/SiemensEx5.jpg)

If you opt for a peripheral input, you can convert it to the correct measuring range using the screen *“Process value settings”*.

![Siemens Example](../PDB/Images/SiemensEx6.jpg)


The P, I and D action can be set via the screen *“PID Parameters”*. Notice that the different actions cannot be selected individually. One can only make a choice between a PID and a PI controller. Note that every action is separately correctable. For example, one can calculate the weight of the P action and the D-action can be individually adjusted to even turn off and one can assign a wait coefficient for the D action.

![Siemens Example](../PDB/Images/SiemensEx7.jpg)


The output can be limited just like a continue controller. This can be done in the *"Output value limits"* screen.

![Siemens Example](../PDB/Images/SiemensEx8.jpg)


Because of the different parameters being adjustable by using pop-up screens, the PID building block will be compacter than the continuing Siemens PID controller.

![Siemens Example](../PDB/Images/SiemensEx9.jpg)


### Programming example – Continue PID controller

In the programming example below will you find the programming of a continue PID controller.

The analog pressure sensor %IW256 gets formed internally so that the following results are obtained:

  -   PV_NORM = (output CRP_IN) . PV_FAC + PV_OFF

  -   PV_NORM = (output CRP_IN) . 0,11 + 1.0

  -   1.0 bar = ( 0%) . 0,11 + 1.0

  -   12.0 bar = (100%) . 0,11 + 1.0

  The loop manipulated value is variable adjustable suing %MD20. This way we can adjust the loop manipulated value with changing the user program.

  The dead band is adjustable at 1.2 bar. In case (W - XDo/2) \< X \< (W + XDo /2)
  The output of the controller doesn't change.

  The controller is adjustable so that:

  -   The P-action is activated and the gain is set to 5.2

  -   The I-action is activated and the reset time is set to 2 min.

  -   The D-action is deactivated

  The output is limited between 0 and 100+ (standard settings) and transformed to the peripheral output %PQW320.

  Notice that the values are shown in light grey colour which are the standard values.

  | **The PID buildblock gets saved by TIA PORTAL in the folder“Program Blocks\\System Blocks\\Program Resources”** |
  |------------------------------------------------------------------------------------------|

  ![Siemens Example](../PDB/Images/SiemensEx10.jpg)

## Controller cicruit structuring

[8.2 Addendum 5 Controllers](#8-3-addendum-5-controllers)
### Singular control circuit

  This is the simplest control circuit. The controller keeps the controlled unit [X] stable on the set value [W]

  ![Single Circuit Example](../PDB/Images/SingleCircuitjpg.jpg)


  Singular feedback control circuits are commonly used where the influence of the controldynamic and the control result are minor.

  ### Cascade controller or master/slave controller

  The imperfections of a single control loop are mainly improved by a cascade control. In cascade control, the control loop becomes divided into a main control loop and an auxiliary control loop.
  For this there is at least one main control controller (master) and one auxiliary or follower control (slave) required.
  - The main or control controller regulates the main control variable to the desired one  value [W]
  - The main or control controller returns an analog SI unit [Yf]  which is processed by the auxiliary or follow-up controller as the desired value  [Yf = Wh]
  - The result of the auxiliary or tracking controller [Yh] influences the process of the  analog measurement of the main or control controller

  ![Cascade Example](../PDB/Images/Cascade.jpg)


  Depending on the needs a cascade controller can be equipped with multiple help controllers. Consequently you could place multiple help/follow controllers behind a head controller.


  ### Ratio controller

  The ratio controller has just like a cascade controller a head controller and a help- or follow controller. The intention is to have multiple processunits in a constant ratio. The ratio controller gets used mostly for controlling 2 flow streams, between these 2 flow streams a determined ratio needs to be present.

  The simplest example of a ratio controller is for example the gas and air supply in a gas incinerator. The head controller controls the amount of gas, depending on the desired oven temperature. The help or follow controller gets controlled by the actual value of the head controller which then controls the amount of air.


  ![Ratio Example](../PDB/Images/Ratio.jpg)


  The ratio between both SI units, gas and air gets used with a ratio factor on the setpoint for the control or follow controller.


  ### Mix Ratio Controller

  A mix ratio controller is a ratio controller with a main controller and several subordinate auxiliary or follow-up controllers.

  With the mixing ratio control it is possible to make a product from several basic components consists of mixing [X1, X2,… .Xn] into a final product with a constant mixing ratio.

  The main- or control-controller controls the joint composition [Xg] it controls all subordinate component controllers with its control output [Yf].The percentage share of each component [X1, X2 ..Xn] with respect to the joint mixing ratio [Xg] is entered with the ratio factor "for".

  ![MixRatio Example](../PDB/Images/MixRatio.jpg)


  ### Split range controller

  Some applications need multiple ajustment ratios, that can be achieved with only one adjusting device, for example a controlvalve.

  A split range controller is a controller with one controlling SI unit and multiple controlled SI units.

  The controlling unit divides its actions over for example two adjustment devices.

  Split range controllers get used a lot in systems for heating and cooling.

  In case the controlled variable varies over a big range, will it be useful for applications.

  ![Split Range Example](../PDB/Images/SplitRange.jpg)


  The controller output gets split in parallel paths, each with an adjusting device.


## Software model following ANSI-ISA-88
  [8.4 Addendum 6 S88](#8-4-addendum-6-s88)
### The different parts

  The ANSI/ISA-88 norm or the **S88 software model** is a norm that describes how a machine/installation (batch)process can be subdivided in different parts.

  The advantage of this is that one big problem[^6] will be divided in different smaller partial problems; smaller problems are often easier to solve than bigger problems. A strategy will be developed for each small partial problem that will cause the bigger problems to be solved one by one.


  [^6]: Within (process)automation this is commonly the automation of an entire machine/installation.
  The S88 software model divides a machine/installation proces in 3 big parts:

  -   The physical part

  -   The procedure part

  -   The recipe part

  ![S88 Software Design ](../Ad06/Images/S88_Softwaredesign.jpg)

  Because the S88 software model is very abstract and expanded we will be using a very simple form in this course:


  -   The back spine is the physical part

  -   The procedure part gets integrated in the physical part.

  -   The recipe part won't be applied

  This means that the software building blocks only get designed for the processing of the physic part or only the procedure part.
  The building blocks will exhange information between each other.

  The following chapters describe different building blocks that are included in the software library. The operation of each individual building block is explained with the use of a operation scheme with the following symbols:

  | **Symbol** | **Description**                                                                                                             |
  |-------------|------------------------------------------------------------------------------------------------------------------------------|
  |     ![AND port ](../Ad06/Images/AND.jpg)        | AND port                                                                                                                    |
  |     ![OR port ](../Ad06/Images/OR.jpg)        | OR Port                                                                                                                     |
  |      ![Not connection ](../Ad06/Images/NOT-connection.jpg)       | NOT connection                                                                                                               |
  |        ![OR port ](../Ad06/Images/OR.jpg)     | Connection                                                                                                                   |
  |     ![TON ](../Ad06/Images/TON.jpg)        | Risedelay                                                                                                              |
  |        ![TOF ](../Ad06/Images/TOF.jpg)     | Drop-off delay                                                                                                             |
  |      ![Time pulse ](../Ad06/Images/TP.jpg)       | Time Puls                                                                                                                     |
  |             | A collection of instructions that together a combination basiccircuit form (in this case the start-stop circuit)  |
  |       ![Positive flank ](../Ad06/Images/Pflank.jpg)      | Positive flank signal                                                                                                       |
  |        ![Negative flank ](../Ad06/Images/Nflank.jpg)     | Negative flank signal                                                                                                       |

  The operation scheme gets drawn up so that every incoming signal is as far to the left as possible and all output signals are to the right. Connections are when needed drawn with dotted lines (with crossing lines) to avoid confusion.

  # Physical part - Control modules
  **Control modules** are software blocks that
    - Process sensor input singals (%I)
    - Activate / control output signals (%Q)

  This way a control module gets represented by a certain type of actuator or sensor and by preference gets included in the software library.
  Control modules are preferably progammed in "Function buildblocks" whereby, the TAG-naming gets expanded with the letters CM.

  _Examples_
  | Tag | Processing of a digital sensor  |
  |--|---|
  | FB_CM_DI_Sensor |  Processing of a digital sensor |
  | FB_CM_AI_Sensor | Processing of an analog sensor |
  | FB_CM_DOL	| Controlling an asynchronous motor with 1 speed and 1 rotating direction   |
  | FB_CM_DOLRev	   | Controlling an asynchronous motor with 1 speed and 2 rotating directions    |
  | FB_CM_Valve   | Controlling of a (pressurised air) valve  |
  | FB_CM_Relay   | Controlling of a relay |
  | FB_CM_Lamp  | Controlling of a (LED) lamp  |
